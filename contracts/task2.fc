#include "imports/stdlib.fc";

const ADDUSER = 0x368ddef3;
const REMOVEUSER = 0x278205c8;
const SPLIT = 0x068530b3;
const TRANSFER = 0x7362d09c;

slice parse_sender_address (cell in_msg_full) inline {
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    ;; cs~load_msg_addr(); ;; skip dst
    ;; cs~load_coins(); ;; skip value
    ;; cs~skip_bits(1); ;; skip extracurrency collection
    ;; cs~load_coins(); ;; skip ihr_fee
    ;; int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs

    return sender_address;
}

int get_fee (cell in_msg_full) inline {
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
     cs~load_msg_addr(); ;;sender_address

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs
    return fwd_fee;

}

(slice) get_serialized_address(int workchain, int address) inline {
    return (begin_cell()
        .store_uint(2, 2)  ;; Is std address
        .store_uint(0, 1)  ;; Non-unicast
        .store_uint(workchain, 8)  ;; Basic workchain
        .store_uint(address, 256) ;; Address hash
    ).end_cell().begin_parse();
}

() messages::send_empty(int amount, slice to, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to)
        .store_coins(amount)
        .store_uint(0, 107)
    .end_cell();
    send_raw_message(msg, mode);
}

(int) utils::to_ton(int amount) inline {
    return amount * 1000000000;
}

(int) utils::from_ton(int amount) inline {
    return amount / 1000000000;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg) impure {
    if (in_msg.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    var (op, query_id) = (in_msg~load_uint(32), in_msg~load_uint(64));

    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    var admin_address = ds~load_msg_addr();

    if(op == ADDUSER) {
        slice sender_address = parse_sender_address(in_msg_full);
        throw_if(120, ~ equal_slices(sender_address, admin_address));

        cell users = ds~load_dict();
        if(dict_empty?(users)) {
            users = new_dict();
        }
        ;; (int epyt, cell users) = (ds~load_uint(1), ds~load_ref());
        slice addressInt = in_msg~load_msg_addr();
        ;; slice address =  begin_cell().store_uint(addressHash, 256).end_cell().begin_parse();
        int share = in_msg~load_uint(32);
        (int workchain, int addressHash) = parse_std_addr(addressInt);
        users~udict_set_builder(256, addressHash, begin_cell().store_uint(share, 32)); ;;udict_set_builder

        set_data(begin_cell()
            .store_slice(admin_address) ;; destination address
            .store_dict(users)
           .end_cell());
        return ();
    }

    if(op == REMOVEUSER) {
        slice sender_address = parse_sender_address(in_msg_full);
        throw_if(120, ~ equal_slices(sender_address, admin_address));

        slice addressInt = in_msg~load_msg_addr();
        (int workchain, int addressHash) = parse_std_addr(addressInt);
        cell users = ds~load_dict();
         
        ;; throw_if(121, users.dict_empty?());
        int success? = users~udict_delete?(256, addressHash);
        throw_unless(121, success?);
         set_data(begin_cell()
            .store_slice(admin_address) ;; destination address
            .store_dict(users)
           .end_cell());
        return ();
    }

    if(op == SPLIT) {
        cell users = ds~load_dict();
        throw_if(122, users.dict_empty?());
       (int key, slice val, int success) = users.udict_get_min?(256);
        int total_share = val~load_uint(32);
        while (success) {
            ;; do something with pair key->val
            (key, val, success) = users.udict_get_next?(256, key);
            if (success) {
                int share = val~load_uint(32);
                total_share += share;
            }
        }
       {
            (int key, slice val, int success) = users.udict_get_min?(256);
            int total_share = val~load_uint(32);
            int fee = get_fee(in_msg_full);
            while (success) {
                ;; do something with pair key->val
                (key, val, success) = users.udict_get_next?(256, key);
                if (success) {
                    int share = val~load_uint(32);
                     cell msg = begin_cell()
                        .store_uint(0x18, 6) ;; flags
                        ;; .store_slice(admin_address) ;; destination address
                        .store_slice(get_serialized_address(0, key)) ;; destination address
                        .store_coins(muldiv(share, msg_value, total_share)) ;; we don't care about this value right now
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
                    .end_cell();
                    send_raw_message(msg, 1);
                }
            }
       }

        return ();
    }
    ;; https://github.com/romanovichim/TonFunClessons_Eng/blob/main/lessons/smartcontract/9lesson/ninthlesson.md
    if(op == TRANSFER) {
        cell users = ds~load_dict();
        throw_if(122, users.dict_empty?());
        int amount = in_msg~load_coins();

        (int key, slice val, int success) = users.udict_get_min?(256);
        int total_share = val~load_uint(32);
        while (success) {
            ;; do something with pair key->val
            (key, val, success) = users.udict_get_next?(256, key);
            if (success) {
                int share = val~load_uint(32);
                total_share += share;
            }
        }

        {
            slice sender_address = parse_sender_address(in_msg_full);
            (int key, slice val, int success) = users.udict_get_min?(256);
            int total_share = val~load_uint(32);
            while (success) {
                ;; do something with pair key->val
                (key, val, success) = users.udict_get_next?(256, key);
                if (success) {
                    int share = val~load_uint(32);
                    cell trans_msg_body = begin_cell()
                        .store_uint(0x7362d09c, 32)
                        .store_uint(query_id, 64)
                        .store_coins((share * amount) / total_share)
                        .store_slice(admin_address) ;; sender_address / get_serialized_address(0, key) is from_address  ? is OK?
                        ;; .store_slice(get_serialized_address(0, key)) ;; is from_address  IS OK?
                        .end_cell();
                    ;; .store_slice(either_forward_payload)

                    cell msg = begin_cell()
                    .store_uint(0x10, 6) ;; we should not bounce here cause receiver can have uninitialized contract
                    .store_slice(get_serialized_address(0, key))  ;; ? sender_address admin_address is 9/11 ok all?
                    .store_coins(1) ;;forward_ton_amount
                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_ref(trans_msg_body)
                    .end_cell();

                    send_raw_message(msg, 1);

                    var msg = begin_cell()
                        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000
                        .store_slice(get_serialized_address(0, key))
                        .store_coins(20000000)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        .store_uint(0xd53276db, 32)
                        .store_uint(query_id, 64);
                    send_raw_message(msg.end_cell(), 2);
                }
            }
            
        }

        return ();
    }

   return ();
}


cell get_users() method_id {
    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    slice addr = ds~load_msg_addr();
    ;; int epyt = ds~load_uint(1);
    cell users = ds~load_dict();
    return users;
    ;; cell dic  = new_dict();
    ;; dic~udict_set_builder(8,8,begin_cell().store_uint(8, 88));
    ;; return dic;
}

int get_user_share(slice user_address) method_id {
    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    slice addr = ds~load_msg_addr();
    var users = ds~load_dict();
    if(dict_empty?(users)) {
        users = new_dict();
    }
    (int workchain, int addressHash) = parse_std_addr(user_address);
    ;; slice address =  begin_cell().store_uint(addressHash, 256).end_cell().begin_parse();
    ;; var (dict, a, share_s, success) = dict.udict_get?(256, address);
    (slice share_s, int success) = users.udict_get?(256, addressHash);
    if(~ success) {
        return null();
    }
    int share = share_s~load_uint(32);
    ;; (cell c, int share) = users.udict_get?(256, addressHash);
    return share;
}

(slice, slice, int, int, int) get_admin() method_id {
     var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    var admin_address = ds~load_msg_addr();
   
    (int wc, int addr) = parse_std_addr(admin_address);
    slice parsed =  get_serialized_address(wc, addr);
    return (admin_address, parsed, wc, addr, equal_slices(admin_address,parsed));
}