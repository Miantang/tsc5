#include "imports/stdlib.fc";

int min_tons_for_storage() asm "10000000 PUSHINT"; ;; 0.01 TON
;; Note that 2 * gas_consumptions is expected to be able to cover fees on both wallets (sender and receiver)
;; and also constant fees on inter-wallet interaction, in particular fwd fee on state_init transfer
;; that means that you need to reconsider this fee when:
;; a) jetton logic become more gas-heavy
;; b) jetton-wallet code (sent with inter-wallet message) become larger or smaller
;; c) global fee changes / different workchain
int gas_consumption() asm "15000000 PUSHINT"; ;; 0.015 TON

const ADDUSER = 0x368ddef3;
const REMOVEUSER = 0x278205c8;
const SPLIT = 0x068530b3;
const TRANSFER = 0x7362d09c;

(slice) get_serialized_address(int workchain, int address) inline {
    return (begin_cell()
        .store_uint(2, 2)  ;; Is std address
        .store_uint(0, 1)  ;; Non-unicast
        .store_uint(workchain, 8)  ;; Basic workchain
        .store_uint(address, 256) ;; Address hash
    ).end_cell().begin_parse();
}

(int) utils::to_ton(int amount) inline {
    return amount * 1000000000;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg) impure {
    if (in_msg.slice_bits() < 32) { ;; ignore empty messages
        return ();
    }
    var (op, query_id) = (in_msg~load_uint(32), in_msg~load_uint(64));

    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    var admin_address = ds~load_msg_addr();
    cell users = ds~load_dict();

    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    ;; if(flags & 1) {
    ;;     return ();
    ;; }
    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    ;; int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs
    ;; var value_to_share = my_balance - fwd_fee;
    ;;     if (value_to_share <= 0) {
    ;;     return ();
    ;; }


    if(op == ADDUSER) {
        throw_if(120, ~ equal_slices(sender_address, admin_address));
        
        ;; throw_if(122, users.dict_empty?());
        slice addressInt = in_msg~load_msg_addr();
        int share = in_msg~load_uint(32);
        (int workchain, int addressHash) = parse_std_addr(addressInt);
        users~udict_set_builder(256, addressHash, begin_cell().store_uint(share, 32)); ;;udict_set_builder

        set_data(begin_cell()
            .store_slice(admin_address) ;; destination address
            .store_dict(users)
           .end_cell());
        return ();
    }

    if(op == REMOVEUSER) {
        throw_if(120, ~ equal_slices(sender_address, admin_address));
        slice addressInt = in_msg~load_msg_addr();
        (int workchain, int addressHash) = parse_std_addr(addressInt);
         
        throw_if(122, users.dict_empty?());
        int success? = users~udict_delete?(256, addressHash);
        throw_unless(121, success?);
         set_data(begin_cell()
            .store_slice(admin_address) ;; destination address
            .store_dict(users)
           .end_cell());
        return ();
    }

    if(op == SPLIT) {
        throw_if(122, users.dict_empty?());
        ;; throw_if(120, ~ equal_slices(sender_address, admin_address));
       (int key, slice val, int success) = users.udict_get_min?(256);
        int total_share = val~load_uint(32);
        while (success) {
            ;; do something with pair key->val
            (key, val, success) = users.udict_get_next?(256, key);
            if (success) {
                int share = val~load_uint(32);
                total_share += share;
            }
        }
       {
            (int key, slice val, int success) = users.udict_get_min?(256);
            int share = val~load_uint(32);
            int ton_to_send = muldiv(share, msg_value, total_share);
                cell msg = begin_cell()
                .store_uint(0x18, 6) ;; flags
                .store_slice(get_serialized_address(0, key)) ;; destination address
                .store_coins(ton_to_send) 
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
            .end_cell();
            send_raw_message(msg, 1);

            while (success) {
                (key, slice share_s, success) = users.udict_get_next?(256, key);
                if (success) {
                    int share = share_s~load_uint(32);
                    int ton_to_send = muldiv(share, msg_value, total_share);
                     cell msg = begin_cell()
                        .store_uint(0x18, 6) ;; flags
                        .store_slice(get_serialized_address(0, key)) ;; destination address
                        .store_coins(ton_to_send) 
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
                    .end_cell();
                    send_raw_message(msg, 1);
                }
            }
       }

        return ();
    }
    ;; https://github.com/romanovichim/TonFunClessons_Eng/blob/main/lessons/smartcontract/9lesson/ninthlesson.md
    if(op == TRANSFER) {
        throw_if(122, users.dict_empty?());
        int amount = in_msg~load_coins();

        (int key, slice val, int success) = users.udict_get_min?(256);
        int total_share = val~load_uint(32);
        while (success) {
            ;; do something with pair key->val
            (key, val, success) = users.udict_get_next?(256, key);
            if (success) {
                int share = val~load_uint(32);
                total_share += share;
            }
        }

        {
            (int key, slice val, int success) = users.udict_get_min?(256);
            slice userAddr = get_serialized_address(0, key);
            if (success) {
                int share = val~load_uint(32);
                int jetton_amount = muldiv(share, amount, total_share);

                var msg_body = begin_cell()
                    .store_uint(0x0f8a7ea5, 32)
                    .store_uint(query_id, 64)
                    .store_coins(jetton_amount)
                    .store_slice(userAddr) ;; owner_address
                    .store_slice(userAddr)  ;;response_address
                    .store_uint(0, 1) ;; custom_payload
                    .store_coins(1) ;; forward_ton_amount
                    .store_uint(0, 1); ;; either_forward_payload

                var transfer_msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(sender_address)
                    .store_coins(20000000)
                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    ;; .store_ref(begin_cell().end_cell())
                    ;; .store_uint(1, 1)
                    .store_ref(msg_body.end_cell());
                
                send_raw_message(transfer_msg.end_cell(), 1); ;; revert on errors

            }
            while (success) {
                ;; do something with pair key->val
                (key, val, success) = users.udict_get_next?(256, key);
                slice userAddr = get_serialized_address(0, key);
                if (success) {
                    int share = val~load_uint(32);
                    int jetton_amount = muldiv(share, amount, total_share);

                    var msg_body = begin_cell()
                        .store_uint(0x0f8a7ea5, 32)
                        .store_uint(query_id, 64)
                        .store_coins(jetton_amount)
                        .store_slice(userAddr) ;; owner_address
                        .store_slice(userAddr)  ;;response_address
                        .store_uint(0, 1) ;; custom_payload
                        .store_coins(1) ;; forward_ton_amount
                        .store_uint(0, 1); ;; either_forward_payload

                    var transfer_msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(sender_address)
                        .store_coins(20000000)
                        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        ;; .store_ref(begin_cell().end_cell())
                        ;; .store_uint(1, 1)
                        .store_ref(msg_body.end_cell());
                    
                    send_raw_message(transfer_msg.end_cell(), 1); ;; revert on errors

                }
            }
            
        }

        return ();
    }

   return ();
}


cell get_users() method_id {
    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    slice addr = ds~load_msg_addr();
    ;; int epyt = ds~load_uint(1);
    return ds~load_dict();
    ;; return ds.preload_dict();
}

int get_user_share(slice user_address) method_id {
    var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    slice addr = ds~load_msg_addr();
    var users = ds~load_dict();
    (int workchain, int addressHash) = parse_std_addr(user_address);
    (slice share_s, int success) = users.udict_get?(256, addressHash);
    return share_s~load_uint(32);
    ;; return 1;
}

(slice, slice, int, int, int) get_admin() method_id {
     var ds = get_data().begin_parse(); ;; get data from storage and convert it into a slice to be able to read values
    var admin_address = ds~load_msg_addr();
   
    (int wc, int addr) = parse_std_addr(admin_address);
    slice parsed =  get_serialized_address(wc, addr);
    return (admin_address, parsed, wc, addr, equal_slices(admin_address,parsed));
}