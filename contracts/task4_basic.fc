#include "imports/stdlib.fc";

forall X -> tuple tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
forall X -> (tuple, ()) ~tset(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
forall X -> tuple tuples::tsetq(tuple t, int k, X x) asm(t x k) "SETINDEXVARQ";
forall X -> (tuple, ()) ~tsetq(tuple t, int k, X x) asm(t x k) "SETINDEXVARQ";
forall X -> (int) tuples::is_tuple(X t) asm "ISTUPLE";

forall X -> (tuple, X) tpop(tuple t) asm "TPOP";
(int) tlen (tuple t) asm "TLEN";
int tuples::tlenq(tuple t) asm "QTLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";

forall X -> X g(tuple t, int k) asm(t k) "INDEXVAR";
forall X -> tuple s(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";

;; () iterate_tuple (tuple t) impure {
;;     repeat (t.tuple_length()) {
;;         var value = t~tpop();
;;         if (is_tuple(value)) {
;;             tuple tuple_value = cast_to_tuple(value);
;;             iterate_tuple(tuple_value);
;;         }
;;         else {
;;             if(value > max_value) {
;;                 max_value = value;
;;             }
;;         }
;;     }
;; }

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

;; int BFS(Node start, Node target) {
;;     Queue<Node> q; // 核心数据结构
;;     Set<Node> visited; // 避免走回头路
    
;;     q.offer(start); // 将起点加入队列
;;     visited.add(start);

;;     while (q not empty) {
;;         int sz = q.size();
;;         /* 将当前队列中的所有节点向四周扩散 */
;;         for (int i = 0; i < sz; i++) {
;;             Node cur = q.poll();
;;             /* 划重点：这里判断是否到达终点 */
;;             if (cur is target)
;;                 return step;
;;             /* 将 cur 的相邻节点加入队列 */
;;             for (Node x : cur.adj()) {
;;                 if (x not in visited) {
;;                     q.offer(x);
;;                     visited.add(x);
;;                 }
;;             }
;;         }
;;     }
;;     // 如果走到这里，说明在图中没有找到目标节点
;; }

int one(int x, int y) inline {
    return x * 100 + y;
}

(int, int) point(int xy) inline {
    return (xy / 100, xy % 100);
}

(int, int) point_move(int xy, int dx, int dy) inline {
    return (xy / 100 + dx, xy % 100 + dy);
}

tuple attach(tuple originMaze, tuple queue) inline {
    ;; queue~tpop(); ;; 去除起点
     repeat (queue.tlen()) {
        int xy = queue~tpop();
        (int x, int y) = point(xy);
        tuple line = originMaze.g(x).tset(y, 33);
        originMaze.tset(x, line);
    }
    return originMaze;
}

(tuple, int) ~unshift(tuple queue) inline {
    tuple t2 = empty_tuple();
    int fst = queue.first();
    repeat (queue.tlen() - 1) {
        t2~tpush(queue~tpop());
    }
    return (t2, fst);
}


;; S 83  E 69 X88  .46  ?63 !33
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    tuple queue = empty_tuple();
    cell visited = new_dict();
    tuple dx = to_tuple([1, 0, -1, 0, 1, -1, -1, 1]);
    tuple dy = to_tuple([0, 1, 0, -1, -1, 1, -1, 1]);
    int findN = 0; 
    int findM = 0;
    int S = null();
    int E = null();

    do {
        do {
            if(maze.g(findN).g(findM) == 83) {
                S = one(findN, findM);
            }
            if(maze.g(findN).g(findM) == 69) {
                E = one(findN, findM);
            }

            findM += 1;
        } until (findM == m);
        findN += 1;
    } until (findN == n);

    queue~tpush(S);
    visited~udict_set_builder(8, S, begin_cell().store_uint(1, 1));

    int len = queue.tlen();

    while(queue.tlen() != 0) {
        int fst = queue~unshift();
        int dIndex = 0;
        while(dIndex < 8) {
            (int nx, int ny) = point_move(fst, dx.g(dIndex), dy.g(dIndex)); ;; 新坐标
            if ((0 <= nx) & (nx < n) & ( 0 <= ny) & (ny < m)) { ;; 迷宫内的坐标
                int p = one(nx, ny);
                var (_, success) = visited.udict_get?(8, p);
                if(~ success) {
                    int character = maze.g(nx).g(ny);
                    if(character == 69) { ;; E
                        return (-1, 0, queue.tlen() - 1, maze);
                    }
                    if(character == 46) { ;; .
                        queue~tpush(p);
                        visited~udict_set_builder(8, p, begin_cell().store_uint(1, 1));
                    }

                    if(character == 63) { ;;?

                    }

                    ;; if(character )
                }

            } 
            dIndex += 1;
        }

    }
    return (-1, 0, 0, null());
    ;; return (-1, maze.g(0).g(2), maze.g(0).g(3), maze);
}